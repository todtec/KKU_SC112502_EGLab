# บทนำสู่ภาษา R: คู่มือการเขียนโปรแกรมเบื้องต้น

## การคำนวณพื้นฐานและการแสดงผลลัพธ์

ผู้ใช้สามารถได้รับผลลัพธ์จากภาษา R ได้โดยการพิมพ์นิพจน์ทางคณิตศาสตร์ใน console:

```r
3 + 5
12 / 7
```

อย่างไรก็ตาม เพื่อดำเนินการที่มีประโยชน์และน่าสนใจ จำเป็นต้องกำหนดค่าให้กับ objects การสร้าง object จำเป็นต้องกำหนดชื่อตามด้วยตัวดำเนินการกำหนดค่า `<-` และค่าที่ต้องการให้:

```r
score_math <- 85
```

`<-` เป็นตัวดำเนินการกำหนดค่า (assignment operator) ซึ่งกำหนดค่าทางขวามือให้กับ objects ทางซ้ายมือ ดังนั้น หลังจากการประมวลผล `score_math <- 85` ค่าของ `score_math` จะเป็น 85 ลูกศรสามารถอ่านได้ว่า "85 เข้าไปใน score_math" ด้วยเหตุผลทางประวัติศาสตร์ ผู้ใช้สามารถใช้ `=` สำหรับการกำหนดค่าได้เช่นกัน แต่ไม่สามารถใช้ได้ในทุกบริบท เนื่องจากมี[ความแตกต่าง](http://blog.revolutionanalytics.com/2008/12/use-equals-or-arrow-for-assignment.html)[เล็กน้อย](http://r.789695.n4.nabble.com/Is-there-any-difference-between-and-tp878594p878598.html)ในไวยากรณ์ จึงเป็นแนวปฏิบัติที่ดีในการใช้ `<-` สำหรับการกำหนดค่าเสมอ

ใน RStudio การพิมพ์ Alt + - (กด Alt พร้อมกับปุ่ม - ) จะเขียน `<-` ในการกดครั้งเดียวใน PC ในขณะที่การพิมพ์ Option + - (กด Option พร้อมกับปุ่ม - ) จะทำเช่นเดียวกันใน Mac

## การตั้งชื่อ Objects และแนวปฏิบัติที่ดี

Objects สามารถตั้งชื่อได้อย่างใดก็ได้ เช่น `x`, `current_temperature`, หรือ `student_id` ชื่อ object ควรชัดเจนและไม่ยาวเกินไป ไม่สามารถเริ่มต้นด้วยตัวเลข (เช่น `2x` ไม่ถูกต้อง แต่ `x2` ถูกต้อง) ภาษา R มีความไวต่อตัวพิมพ์ใหญ่-เล็ก (เช่น `grade_science` แตกต่างจาก `Grade_science`) มีชื่อบางอย่างที่ไม่สามารถใช้ได้เนื่องจากเป็นชื่อของฟังก์ชันพื้นฐานในภาษา R (เช่น `if`, `else`, `for` ดู[รายการครบถ้วน](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html))

โดยทั่วไป แม้ว่าจะอนุญาต แต่ควรหลีกเลี่ยงการใช้ชื่อฟังก์ชันอื่น ๆ (เช่น `c`, `T`, `mean`, `data`, `df`, `weights`) หากมีข้อสงสัย ควรตรวจสอบความช่วยเหลือเพื่อดูว่าชื่อนั้นถูกใช้แล้วหรือไม่ นอกจากนี้ ควรหลีกเลี่ยงจุด (`.`) ในชื่อ object เช่น `my.dataset` มีฟังก์ชันมากมายในภาษา R ที่มีจุดในชื่อด้วยเหตุผลทางประวัติศาสตร์ แต่เนื่องจากจุดมีความหมายพิเศษในภาษา R (สำหรับ methods) และภาษาโปรแกรมอื่น ๆ จึงควรหลีกเลี่ยง

ควรใช้คำนามสำหรับชื่อ object และคำกริยาสำหรับชื่อฟังก์ชัน การใช้รูปแบบการเขียนโค้ดที่สม่ำเสมอมีความสำคัญ (ตำแหน่งที่วางช่องว่าง วิธีการตั้งชื่อ objects เป็นต้น) การใช้รูปแบบการเขียนโค้ดที่สม่ำเสมอทำให้โค้ดอ่านง่ายขึ้นสำหรับตัวคุณเองในอนาคตและผู้ร่วมงาน ในภาษา R มีคู่มือรูปแบบที่นิยม 3 แบบ ได้แก่ [Google's](https://google.github.io/styleguide/Rguide.xml), [Jean Fan's](http://jef.works/R-style-guide/) และ [tidyverse's](http://style.tidyverse.org/) คู่มือของ tidyverse มีความครอบคลุมมากและอาจดูท่วมท้นในตอนแรก คุณสามารถติดตั้งแพ็คเกจ [lintr](https://github.com/jimhester/lintr) เพื่อตรวจสอบปัญหาในรูปแบบการเขียนโค้ดโดยอัตโนมัติ

### Objects เทียบกับ Variables

สิ่งที่เรียกว่า **objects** ในภาษา R เรียกว่า **variables** ในภาษาโปรแกรมอื่น ๆ ขึ้นอยู่กับบริบท **object** และ **variable** อาจมีความหมายที่แตกต่างกันอย่างมาก อย่างไรก็ตาม ในบทเรียนนี้ คำทั้งสองใช้แทนกันได้ สำหรับข้อมูลเพิ่มเติม ดู: [https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Objects]

## การทำงานกับ Objects

เมื่อกำหนดค่าให้กับ object ภาษา R จะไม่แสดงผลลัพธ์ คุณสามารถบังคับให้ภาษา R แสดงค่าได้โดยใช้วงเล็บหรือพิมพ์ชื่อ object:

```r
grade_math <- 85    # ไม่แสดงผลลัพธ์
(grade_math <- 85)  # แต่การใส่วงเล็บรอบคำสั่งจะแสดงค่าของ grade_math
grade_math          # และการพิมพ์ชื่อ object ก็จะแสดงค่าเช่นกัน
```

ขณะนี้ภาษา R มี `grade_math` ในหน่วยความจำ เราสามารถทำการคำนวณกับมันได้ ตัวอย่างเช่น เราอาจต้องการแปลงคะแนนนี้ให้เป็นเปอร์เซ็นต์ (คะแนนเปอร์เซ็นต์คือคะแนนหารด้วย 100):

```r
percentage_math <- grade_math / 100
percentage_math
```

เราสามารถเปลี่ยนค่าของ object ได้โดยกำหนดค่าใหม่ให้:

```r
grade_math <- 90
grade_math
```

ซึ่งหมายความว่าการกำหนดค่าให้กับ object หนึ่งไม่ได้เปลี่ยนค่าของ objects อื่น ตัวอย่างเช่น มาเก็บคะแนนวิทยาศาสตร์ของนักเรียนใน object ใหม่ `grade_science`:

```r
grade_science <- grade_math * 0.95
grade_science
```

จากนั้นเปลี่ยน `grade_math` เป็น 100:

```r
grade_math <- 100
```

คุณคิดว่าเนื้อหาปัจจุบันของ object `grade_science` คืออะไร? 85.5 หรือ 95?

## ฟังก์ชัน (Functions)

ฟังก์ชันเป็น "สคริปต์กระป๋อง" ที่ทำการอัตโนมัติชุดคำสั่งที่ซับซ้อนมากขึ้น รวมถึงการดำเนินการ การกำหนดค่า เป็นต้น ฟังก์ชันจำนวนมากถูกกำหนดไว้ล่วงหน้า หรือสามารถทำให้พร้อมใช้งานได้โดยการนำเข้าแพ็คเกจภาษา R (จะกล่าวถึงในภายหลัง) ฟังก์ชันมักจะ (แต่ไม่เสมอ) รับอินพุตหนึ่งหรือมากกว่าที่เรียกว่า arguments ฟังก์ชันมักจะ (แต่ไม่เสมอ) คืนค่า ตัวอย่างทั่วไปคือฟังก์ชัน `sqrt()` อินพุต (argument) ต้องเป็นตัวเลข และค่าที่คืนกลับ (ในความเป็นจริงคือ output) คือรากที่สองของตัวเลขนั้น การดำเนินการฟังก์ชัน ('การรันมัน') เรียกว่าการเรียกฟังก์ชัน ตัวอย่างของการเรียกฟังก์ชัน:

```r
score_total <- 400
score_average <- sqrt(score_total)
score_average
```

ที่นี่ ค่าของ `score_total` ถูกส่งให้กับฟังก์ชัน `sqrt()` ฟังก์ชัน `sqrt()` คำนวณรากที่สอง และคืนค่าซึ่งจากนั้นถูกกำหนดให้กับ object `score_average` ฟังก์ชันนี้ง่ายมาก เพราะรับ argument เพียงตัวเดียว

'ค่า' ที่คืนกลับของฟังก์ชันไม่จำเป็นต้องเป็นตัวเลข (เช่น `sqrt()`) และไม่จำเป็นต้องเป็นรายการเดียว: อาจเป็นชุดของสิ่งต่าง ๆ หรือแม้แต่ชุดข้อมูล เราจะเห็นสิ่งนี้เมื่อเราอ่านไฟล์ข้อมูลเข้าสู่ภาษา R

Arguments สามารถเป็นอะไรก็ได้ ไม่เพียงแต่ตัวเลขหรือชื่อไฟล์ แต่รวมถึง objects อื่น ๆ ด้วย ความหมายของแต่ละ argument แตกต่างกันไปตามฟังก์ชัน และต้องค้นหาในเอกสารประกอบ (ดูด้านล่าง) ฟังก์ชันบางตัวรับ arguments ซึ่งอาจถูกระบุโดยผู้ใช้ หรือหากละเว้น จะใช้ค่าเริ่มต้น: เรียกว่า options Options มักใช้เพื่อเปลี่ยนแปลงวิธีการทำงานของฟังก์ชัน เช่น ว่าจะเพิกเฉยต่อ 'ค่าที่ไม่ดี' หรือสัญลักษณ์ใดที่จะใช้ในกราฟ อย่างไรก็ตาม หากคุณต้องการสิ่งเฉพาะ คุณสามารถระบุค่าที่คุณเลือกซึ่งจะถูกใช้แทนค่าเริ่มต้น

มาลองฟังก์ชันที่สามารถรับ arguments หลายตัว: `round()`:

```r
round(3.14159)
#> [1] 3
```

ที่นี่ เราได้เรียก `round()` ด้วย argument เพียงตัวเดียว `3.14159` และมันคืนค่า `3` นั่นเป็นเพราะค่าเริ่มต้นคือการปัดเศษเป็นจำนวนเต็มที่ใกล้ที่สุด หากเราต้องการทศนิยมมากขึ้น เราสามารถดูวิธีการทำโดยการรับข้อมูลเกี่ยวกับฟังก์ชัน `round` เราสามารถใช้ `args(round)` เพื่อหา arguments ที่รับ หรือดูความช่วยเหลือสำหรับฟังก์ชันนี้โดยใช้ `?round`

```r
args(round)
#> function (x, digits = 0)
#> NULL
```

เราเห็นว่าหากเราต้องการจำนวนหลักที่แตกต่างกัน เราสามารถพิมพ์ `digits = 2` หรือจำนวนที่เราต้องการ:

```r
round(3.14159, digits = 2)
#> [1] 3.14
```

หากคุณระบุ arguments ในลำดับเดียวกับที่กำหนดไว้ คุณไม่จำเป็นต้องตั้งชื่อ:

```r
round(3.14159, 2)
#> [1] 3.14
```

และหากคุณตั้งชื่อ arguments คุณสามารถสลับลำดับได้:

```r
round(digits = 2, x = 3.14159)
#> [1] 3.14
```

เป็นแนวปฏิบัติที่ดีในการวาง arguments ที่ไม่ใช่ตัวเลือก (เช่น ตัวเลขที่คุณกำลังปัดเศษ) ไว้ก่อนในการเรียกฟังก์ชันของคุณ และจากนั้นระบุชื่อของ arguments ที่เป็นตัวเลือกทั้งหมด หากคุณไม่ทำเช่นนั้น คนที่อ่านโค้ดของคุณอาจต้องค้นหานิยามของฟังก์ชันที่มี arguments ที่ไม่คุ้นเคยเพื่อเข้าใจสิ่งที่คุณกำลังทำ

## Vectors

Vector เป็นประเภทข้อมูลที่พบมากที่สุดและพื้นฐานที่สุดในภาษา R และเป็นเสาหลักของภาษา R Vector ประกอบด้วยชุดของค่า ซึ่งสามารถเป็นตัวเลขหรือตัวอักษร เราสามารถกำหนดชุดของค่าให้กับ vector โดยใช้ฟังก์ชัน `c()` ตัวอย่างเช่น เราสามารถสร้าง vector ของคะแนนสอบและกำหนดให้กับ object ใหม่ `exam_scores`:

```r
exam_scores <- c(85, 92, 78, 96, 88)
exam_scores
```

Vector ยังสามารถมีตัวอักษร:

```r
subjects <- c("mathematics", "science", "english", "history", "art")
subjects
```

เครื่องหมายคำพูดรอบ "mathematics", "science" เป็นต้น มีความจำเป็นที่นี่ หากไม่มีเครื่องหมายคำพูด ภาษา R จะสมมติว่ามี objects ถูกสร้างขึ้นชื่อ `mathematics`, `science` และ `english` เนื่องจาก objects เหล่านี้ไม่มีอยู่ในหน่วยความจำของภาษา R จะมีข้อความแสดงข้อผิดพลาด

มีฟังก์ชันมากมายที่ช่วยให้คุณตรวจสอบเนื้อหาของ vector `length()` บอกว่ามีองค์ประกอบกี่ตัวใน vector นั้น:

```r
length(exam_scores)
length(subjects)
```

คุณลักษณะสำคัญของ vector คือองค์ประกอบทั้งหมดเป็นประเภทข้อมูลเดียวกัน ฟังก์ชัน `class()` บ่งชี้คลาส (ประเภทขององค์ประกอบ) ของ object:

```r
class(exam_scores)
class(subjects)
```

ฟังก์ชัน `str()` ให้ภาพรวมของโครงสร้างของ object และองค์ประกอบของมัน เป็นฟังก์ชันที่มีประโยชน์เมื่อทำงานกับ objects ขนาดใหญ่และซับซ้อน:

```r
str(exam_scores)
str(subjects)
```

คุณสามารถใช้ฟังก์ชัน `c()` เพื่อเพิ่มองค์ประกอบอื่น ๆ ให้กับ vector ของคุณ:

```r
exam_scores <- c(exam_scores, 90)     # เพิ่มที่ส่วนท้ายของ vector
exam_scores <- c(75, exam_scores)     # เพิ่มที่ส่วนต้นของ vector
exam_scores
```

ในบรรทัดแรก เราใช้ vector เดิม `exam_scores` เพิ่มค่า `90` ที่ส่วนท้าย และบันทึกผลลัพธ์กลับเข้าไปใน `exam_scores` จากนั้นเราเพิ่มค่า `75` ที่ส่วนต้น บันทึกผลลัพธ์กลับเข้าไปใน `exam_scores` อีกครั้ง

เราสามารถทำสิ่งนี้ซ้ำแล้วซ้ำเล่าเพื่อขยาย vector หรือประกอบชุดข้อมูล ขณะที่เราเขียนโปรแกรม สิ่งนี้อาจมีประโยชน์ในการเพิ่มผลลัพธ์ที่เรากำลังเก็บรวบรวมหรือคำนวณ

## ประเภทของ Atomic Vectors

Atomic vector เป็นประเภทข้อมูลที่ง่ายที่สุดของภาษา R และเป็น vector เชิงเส้นของประเภทเดียว ข้างต้น เราได้เห็น 2 ใน 6 ประเภท atomic vector หลักที่ภาษา R ใช้: `"character"` และ `"numeric"` (หรือ `"double"`) เหล่านี้เป็นองค์ประกอบพื้นฐานที่ objects ทั้งหมดของภาษา R สร้างขึ้นจาก อีก 4 ประเภท atomic vector ได้แก่:

- `"logical"` สำหรับ `TRUE` และ `FALSE` (ประเภทข้อมูลบูลีน)
- `"integer"` สำหรับจำนวนเต็ม (เช่น `2L` ตัว L บ่งชี้ให้ภาษา R รู้ว่าเป็นจำนวนเต็ม)
- `"complex"` เพื่อแทนจำนวนเชิงซ้อนที่มีส่วนจริงและส่วนจินตภาพ (เช่น `1 + 4i`) และนั่นคือทั้งหมดที่เราจะพูดถึงเรื่องนี้
- `"raw"` สำหรับ bitstreams ที่เราจะไม่หารือต่อไป

คุณสามารถตรวจสอบประเภทของ vector ของคุณโดยใช้ฟังก์ชัน `typeof()` และใส่ vector ของคุณเป็น argument

Vectors เป็นหนึ่งในโครงสร้างข้อมูลมากมายที่ภาษา R ใช้ โครงสร้างสำคัญอื่น ๆ ได้แก่ lists (`list`), matrices (`matrix`), data frames (`data.frame`), factors (`factor`) และ arrays (`array`)

### แบบฝึกหัด

1. สร้าง vector `student_ages` ที่มีอายุของนักเรียน 18, 19, 17, 20 ปี ตามลำดับ
2. อายุรวมของนักเรียนเหล่านี้คือเท่าไร? (คำแนะนำ: ใช้ฟังก์ชัน `sum`)
3. นักเรียนอีกคนหนึ่งถูกวัดและอายุ 21 ปี เพิ่มสิ่งนี้ที่ส่วนต้นของ vector `student_ages` และบันทึกอายุรวมของนักเรียนชุดใหม่ในตัวแปร `total_age` อายุรวมใหม่คือเท่าไร?

## การแยกย่อย (Subsetting) Vectors

หากเราต้องการดึงค่าหนึ่งหรือหลายค่าจาก vector เราต้องระบุดัชนีหนึ่งหรือหลายดัชนีในวงเล็บเหลี่ยม ตัวอย่างเช่น:

```r
subjects[2]
#> [1] "science"
subjects[c(3, 2)]
#> [1] "english" "science"
```

เรายังสามารถทำซ้ำดัชนีเพื่อสร้าง object ที่มีองค์ประกอบมากกว่า object เดิม:

```r
subjects[c(1, 2, 3, 2, 1, 4)]
#> [1] "mathematics" "science" "english" "science" "mathematics" "history"
```

ดัชนีของภาษา R เริ่มต้นที่ 1 ภาษาโปรแกรมเช่น Fortran, MATLAB, Julia และ R เริ่มนับที่ 1 เพราะนั่นคือสิ่งที่มนุษย์มักจะทำ ภาษาในตระกูล C (รวมถึง C++, Java, Perl และ Python) นับจาก 0 เพราะนั่นง่ายกว่าสำหรับคอมพิวเตอร์

วิธีการแยกย่อยที่พบบ่อยอีกวิธีหนึ่งคือการใช้ logical vector `TRUE` จะเลือกองค์ประกอบที่มีดัชนีเดียวกัน ในขณะที่ `FALSE` จะไม่เลือก:

```r
exam_scores[c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE)]
#> [1] 75 85 92 96
```

โดยทั่วไป logical vectors เหล่านี้ไม่ได้พิมพ์ด้วยมือ แต่เป็นผลลัพธ์ของฟังก์ชันอื่นหรือการทดสอบตรรกะ ตัวอย่างเช่น หากคุณต้องการเลือกเฉพาะค่าที่มากกว่า 85:

```r
exam_scores > 85
#> [1] FALSE FALSE TRUE TRUE FALSE TRUE FALSE
exam_scores[exam_scores > 85]
#> [1] 92 96 90
```

คุณสามารถรวมการทดสอบหลายรายการโดยใช้ `&` (เงื่อนไขทั้งสองเป็นจริง AND) หรือ `|` (เงื่อนไขอย่างน้อยหนึ่งข้อเป็นจริง OR):

```r
exam_scores[exam_scores < 80 | exam_scores > 95]
#> [1] 75 96
exam_scores[exam_scores >= 80 & exam_scores <= 90]
#> [1] 85 88 90
```

ที่นี่ `<` หมายถึง "น้อยกว่า" `>` สำหรับ "มากกว่า" `>=` สำหรับ "มากกว่าหรือเท่ากับ" และ `==` สำหรับ "เท่ากับ" เครื่องหมายเท่ากับคู่ `==` เป็นการทดสอบความเท่าเทียมกันเชิงตัวเลขระหว่างซ้ายและขวา และไม่ควรสับสนกับเครื่องหมาย `=` เดี่ยว ซึ่งทำการกำหนดค่าตัวแปร (คล้ายกับ `<-`)

งานทั่วไปคือการค้นหาสตริงบางอย่างใน vector คนหนึ่งสามารถใช้ตัวดำเนินการ "หรือ" `|` เพื่อทดสอบความเท่าเทียมกันกับค่าหลายค่า แต่สิ่งนี้อาจกลายเป็นเรื่องน่าเบื่ออย่างรวดเร็ว ฟังก์ชัน `%in%` ช่วยให้คุณทดสอบว่าองค์ประกอบใดของ search vector ถูกพบหรือไม่:

```r
subjects <- c("mathematics", "science", "english", "history")
subjects[subjects == "history" | subjects == "science"] # คืนค่าทั้ง science และ history
#> [1] "science" "history"
subjects %in% c("science", "english", "art")
#> [1] FALSE TRUE TRUE FALSE
subjects[subjects %in% c("science", "english", "art")]
#> [1] "science" "english"
```

## ข้อมูลที่หายไป (Missing Data)

เนื่องจากภาษา R ถูกออกแบบมาเพื่อวิเคราะห์ชุดข้อมูล จึงรวมแนวคิดของข้อมูลที่หายไป (ซึ่งไม่พบบ่อยในภาษาโปรแกรมอื่น) ข้อมูลที่หายไปแสดงใน vectors เป็น `NA`

เมื่อทำการดำเนินการกับตัวเลข ฟังก์ชันส่วนใหญ่จะคืน `NA` หากข้อมูลที่คุณทำงานด้วยรวมค่าที่หายไป คุณลักษณะนี้ทำให้ยากขึ้นในการมองข้ามกรณีที่คุณจัดการกับข้อมูลที่หายไป คุณสามารถเพิ่ม argument `na.rm = TRUE` เพื่อคำนวณผลลัพธ์โดยเพิกเฉยต่อค่าที่หายไป

```r
test_scores <- c(85, 90, 87, NA, 93)
mean(test_scores)
max(test_scores)
mean(test_scores, na.rm = TRUE)
max(test_scores, na.rm = TRUE)
```

หากข้อมูลของคุณรวมค่าที่หายไป คุณอาจต้องการทำความคุ้นเคยกับฟังก์ชัน `is.na()`, `na.omit()` และ `complete.cases()` ดูตัวอย่างด้านล่าง

```r
## แยกองค์ประกอบที่ไม่ใช่ค่าที่หายไป
test_scores[!is.na(test_scores)]

## คืน object ที่ลบกรณีไม่สมบูรณ์แล้ว object ที่คืนกลับเป็น atomic vector ประเภท "numeric" (หรือ "double")
na.omit(test_scores)

## แยกองค์ประกอบที่เป็นกรณีสมบูรณ์ object ที่คืนกลับเป็น atomic vector ประเภท "numeric" (หรือ "double")
test_scores[complete.cases(test_scores)]
```

จำไว้ว่าคุณสามารถใช้ฟังก์ชัน `typeof()` เพื่อหาประเภทของ atomic vector ของคุณ

### แบบฝึกหัด

ใช้ vector ของคะแนนสอบนี้ สร้าง vector ใหม่ `scores_no_na` โดยลบ NAs ออก ใช้ฟังก์ชัน `median()` เพื่อคำนวณค่ามัธยฐานของ vector `test_scores` นักเรียนกี่คนในชุดที่ได้คะแนนมากกว่า 88

```r
test_scores <- c(82, 91, 78, 87, NA, 89, 85, 93, 86, 77, 83, 90, 84, 82, NA, 95, 88, 81, 92, 84, 87)
```

**คำตอบ**
```r
test_scores <- c(82, 91, 78, 87, NA, 89, 85, 93, 86, 77, 83, 90, 84, 82, NA, 95, 88, 81, 92, 84, 87)
# 1.
scores_no_na <- test_scores[!is.na(test_scores)]
# หรือ
scores_no_na <- na.omit(test_scores)
# หรือ
scores_no_na <- test_scores[complete.cases(test_scores)]

# 2.
median(test_scores, na.rm = TRUE)

# 3.
scores_above_88 <- scores_no_na[scores_no_na > 88]
length(scores_above_88)
```

## ความคิดเห็น (Comments)

ตัวอักษรความคิดเห็นในภาษา R คือ `#` สิ่งใดก็ตามทางขวาของ `#` ในสคริปต์จะถูกเพิกเฉยโดยภาษา R มีประโยชน์ในการทิ้งบันทึกและคำอธิบายในสคริปต์ของคุณ RStudio ทำให้ง่ายในการแสดงความคิดเห็นหรือยกเลิกความคิดเห็นในย่อหน้า: หลังจากเลือกบรรทัดที่คุณต้องการแสดงความคิดเห็น ให้กด Ctrl + Shift + C พร้อมกันบนแป้นพิมพ์ของคุณ หากคุณต้องการแสดงความคิดเห็นเพียงบรรทัดเดียว คุณสามารถวางเคอร์เซอร์ที่ตำแหน่งใดก็ได้ของบรรทัดนั้น (กล่าวคือ ไม่จำเป็นต้องเลือกทั้งบรรทัด) จากนั้นกด Ctrl + Shift + C